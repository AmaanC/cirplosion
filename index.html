<!DOCTYPE HTML>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="user-scalable=no, width=device-width, height=device-height" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Cirplosion - A canvas based game</title>
<style>
body, canvas {
	margin: 0px;
	padding : 0px;
}
.button{
	color : white;
	padding : 10px;
	border : solid white;
	border-radius : 10px;
	overflow : none;
}
</style>
</head>

<body>
<canvas id='canvas'>Your browser doesn't support the canvas element. Try updating your browser, or using a different browser (such as Chrome, Firefox or Safari)</canvas>
<script>
// I'm going to call the weird circle thing that grows the 'bomb' and the other bouncing circles just circles. In the middle somewhere, I played the game again, and started calling them orbs. So circles === orbs

//For scoring:
//1 cirplosion left = 50 points
//1s = 10 points
//Attempts:
//1 attempt = 100 points
//2 attempts = 50 points
//3 attempts = 25 points
//3+ attempts = 0 points

var Game = function (){
	var state = '', //4 states. '', grow, ready, boom. '' is where it just follows the mouse. The other are self-explanatory
	    circles = [], //Array to manage the circles. Each index will be an object with x and y
	    rad = 0,
	    orbRad = 5,
	    canvas,
	    ctx,
	    score = 0, //Private variables ftw!
	    level = 0,
	    orbLevels = [1,2,3,1,5];

	this.init = function (id){
		var that = this;
		canvas = document.getElementById(id);
		ctx = canvas.getContext('2d');
		var touchm = ("ontouchmove" in canvas);
		if(touchm){
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight; // For touch screen devices, make it go fullscreen
			document.body.addEventListener('touchmove', function (e){
				e.preventDefault();
			}, false);
			//Note to self: Opera needs the 3rd boolean paramater in addEventListener.
		}
		else {
			canvas.width = 500;
			canvas.height = 500;
		}
		var md = ('ontouchstart' in canvas) ? "touchstart" : "mousedown";
		var mu = ("ontouchend" in canvas) ? "touchend" : "mouseup";
		var mm = touchm ? "touchmove" : "mousemove";
		
		canvas.addEventListener(md, function (e){
			that.selectedColour = 'rgb('+Math.round(Math.random()*255)+','+Math.round(Math.random()*255)+','+Math.round(Math.random()*255)+')'; //Gives the growing bomb a random colour.
			state = (state === '') ? 'grow' : 'ready'; //If it's just following the mouse around, start growing, else keep it ready.
			that.x = ((touchm) ? e.touches[0].pageX : e.pageX) - this.offsetLeft; //This is canvas, that is Cirplosion
			that.y = ((touchm) ? e.touches[0].pageY : e.pageY) - this.offsetTop; // On some touchscreen phones e.pageX doesn't work, so I have to use e.touches[0].pageX because that works everywhere
			e.preventDefault();
		}, false);
		canvas.addEventListener(mu, function (){
			state = (state === 'grow') ? 'ready' : (state === 'ready') ? 'boom' : ''; //If it was previously growing and didn't burst, make it ready. If it wasn't growing and if it was ready, BOOM!
		}, false);
		canvas.addEventListener(mm, function (e){
			that.x = ((touchm) ? e.touches[0].pageX : e.pageX) - this.offsetLeft;
			that.y = ((touchm) ? e.touches[0].pageY : e.pageY) - this.offsetTop;
			e.preventDefault();
		}, false);
		
		setInterval(function (){
			that.main(); //The function to draw and control all of those bouncing circles and the bomb
		}, 100/3);
		
	};
	
	//MAIN FUNCTION. DOES *EVERYTHING* BECAUSE I COULDN'T THINK OF A WAY TO CREATE SEPERATE FUNCTIONS. SORRY FOR SCREAMING!
	this.collide = function (obj1){
		return (Math.pow(this.x - obj1.x, 2) + Math.pow(this.y - obj1.y, 2) <= Math.pow(rad + obj1.rad, 2)) //Check if any object is colliding with the current bomb
	}
	this.main = function (){ //n is the number of circles to draw. Changes for levels
		canvas.width = canvas.width; //Clear canvas. For some reason, clearRect won't work for me on Chrome
		ctx.fillStyle = 'black';
		ctx.fillRect(0, 0, canvas.width, canvas.height); //Set the background
		
		//Let's make those orbs!
		
		var blasts = [],
		    cir = circles;
		if(cir.length === 0){
			this.drawCircles(orbLevels[level]);
			score++;
			level++;
		}
		else {
			for(var i=0; i < cir.length; i++){
				cir[i].disx *= (cir[i].x + cir[i].rad + cir[i].disx >= canvas.width || cir[i].x - cir[i].rad + cir[i].disx <= 0) ? -1 : 1;
				cir[i].disy *= (cir[i].y + cir[i].rad + cir[i].disy >= canvas.height || cir[i].y - cir[i].rad + cir[i].disy <= 0) ? -1 : 1;
				cir[i].x += cir[i].disx;
				cir[i].y += cir[i].disy;
				this.circle(cir[i].x, cir[i].y, cir[i].rad, 'orange', 1);
			
				//If it collides, check which one it is, growing, or boom-ing
				if( this.collide(cir[i], this) ){
					if(state === 'grow'){
						state = '';
					}
					else if(state === 'boom'){
						cir[i] = undefined;
					}
				}
			}
		}
		
		//if there are any undefined values in the array, remove them.
		while(cir.indexOf(undefined) >= 0){
			cir.splice(cir.indexOf(undefined), 1);
		}
		
		//The bomb's code. I put the orbs first because when the bomb's in the 'ready' state, it should be over the orbs
		switch(state){
			case '':
				rad = 5; //Reset the radius because it burst
				this.circle(this.x, this.y, 5, 'white', 0.5);
				break;
			case 'grow':
				rad++;
				if(	this.x + rad >= canvas.width ||
					this.x - rad <= 0 ||
					this.y + rad >= canvas.height ||
					this.y - rad <= 0
				) {
					state = '';
				}
				
				this.circle(this.x, this.y, rad, this.selectedColour);
				break;
			case 'ready':
				this.circle(this.x, this.y, rad, 'white', 0.5);
				break;
			case 'boom':
				// Have those orbs that didn't blast's speeds affected
				for(var i=0; i < cir.length; i++){
					var distance = Math.sqrt( Math.pow(cir[i].x - this.x, 2) + Math.pow(cir[i].y - this.y, 2) );
					var force = rad * 5/distance;
					var gradient = (cir[i].y - this.y) / (cir[i].x - this.x);
					var xFromImpact = force / Math.sqrt(1 + (gradient * gradient) );
					var yFromImpact = xFromImpact * Math.abs(gradient);
					xFromImpact *= (cir[i].x >= this.x) ? 3 : -3;
					yFromImpact *= (cir[i].y >= this.y) ? 3 : -3;
					cir[i].disx += xFromImpact;
					cir[i].disy += yFromImpact;
				}
				//I know that isn't the best way to be calculating the forces, but I'm lazy, so sorry
				state = ''; //Set it back to following it around
				break;
		}

		
	};
	
	//This is just the inital function used to create the circles at the beginning of each level
	this.drawCircles = function (n){
		var that = this;
		for(var i=0; i < n; i++){
			circles.push(
			{
				rad : orbRad,
				x : orbRad + Math.floor(Math.random() * (canvas.width - orbRad * 2)),
				y : orbRad + Math.floor(Math.random() * (canvas.height - orbRad * 2)),
				disx : (1 + Math.round(Math.random() * 3)) * [1, -1][Math.round(Math.random())], //abs(4) is the max speed
				disy : (1 + Math.round(Math.random() * 3)) * [1, -1][Math.round(Math.random())], //abs(1) is the min speed
			}
			); //Put the object in an array so I can compare it for collision detection
		}
	};
	
	//Easier than ctx.arc each time
	this.circle = function (x, y, rad, colour, alpha){
		ctx.beginPath();
		ctx.fillStyle = colour || 'black';
		ctx.globalAlpha = alpha || 1;
		ctx.arc(x, y, rad, 0, Math.PI * 2, true);
		ctx.closePath();
		ctx.fill();
	};
	
	this.newButton = function (width, height, left, top, text, callback){
		var div = document.createElement('div');
		div.className = 'button';
		div.style.position = 'absolute';
		if(width !== undefined){
			div.style.offsetWidth = width + 'px';
		}
		if(height !== undefined){
			div.style.offsetHeight = height + 'px';
		}
//		div.style.left = left * canvas.width - width/2 + canvas.offsetLeft + 'px';
		div.style.top = top * canvas.height - height/2 + canvas.offsetTop + 'px';
		div.textContent = text;
		document.body.appendChild(div);
		div.addEventListener('click', callback, false);
	}
	
};
var Cirplosion = new Game();
Cirplosion.init('canvas');
</script>
</body>
</html>
